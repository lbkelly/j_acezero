#!/usr/env python

"""
Exports the result of an ace_zero simulation to xcombat output for 3D visualisation. 
"""

import os
import time

import utils

__author__ = 'mikepsn'

class AircraftState(object):
    """State of a single aircraft at a given instance in simulation time."""

    def __init__(self):
        self.timestep = 0
        self.mfly = 0
        self.deadflag = 0
        self.ac_ident = 0
        self.side = 0
        self.x = 0.0
        self.y = 0.0
        self.z = 0.0
        self.psi = 0.0
        self.theta = 0.0
        self.phi = 0.0
        self.alpha = 0.0
        self.mach = 0
        self.throt = 0
        self.eta = 0
        self.actype = 0
        self.msl = []
        self.n_flares = 0
        self.flares = []
        self.beam_elevation = 0
        self.beam_azimuth = 0
        self.horizontal_scan = 0
        self.vertical_scan = 0
        self.radar_range = 0
        self.inst_beam_azimuth = 0
        self.inst_beam_elevation = 0
        self.beam_height = 0
        self.beam_width = 0
        self.clutter_patch_1_x = 0.0
        self.clutter_patch_1_y = 0.0
        self.clutter_patch_2_x = 0.0
        self.clutter_patch_2_y = 0.0
        self.clutter_area_1 = 0.0
        self.clutter_area_2 = 0.0
        self.clutter_lobe_1 = 0.0
        self.clutter_lobe_2 = 0.0
        self.clutter_patch_prf = 0.0
        self.comque = "00000001000"

    def update_state(self, t, x, y, z, psi, theta, phi, v, weight, fuel):
        self.timestep = t
        self.x = x
        self.y = y
        self.z = z
        self.psi = psi
        self.theta = theta
        self.phi = phi
        self.mach = int(100 * utils.mps_to_mach(v))


class Timeslice(object):
    """A timeslice consists of a list of aircraft states for the current simulation timestep. """
    def __init__(self):
        self.aircraft = []


class XCombatRun(object):
    """ A history of a single simulation run.
        Consists of a header followed by a sequence of timeslices. """

    def __init__(self, path, vname, cname, run_no):
        self.version = "VersionD\n"
        self.comment = "ACE ZERO\n"
        self.generated = "Generated by ACE0 for XCombat\n"
        self.model_line = "3 9 10 2 \n"
        self.n_aircraft = 2
        self.n_sides = 2
        self.ac_side_str = str(self.n_aircraft) + " " + str(self.n_sides) + "\n"
        self.n_waypoints = str(0) + "\n"
        self.file = self.create_history_file(path, vname, cname, run_no)
        self.timeslices = []

    def __del__(self):
        if self.file:
            self.file.close()

    def create_history_file(self, path, vname, cname, run_no):
        """ Creates a history run file. The name of the file is automatically generated,
            and includes the date and time of generation.
            By default the run history files are generated in a folder called runs.
            If the folder doesn't exist it is created. """

        localtime = time.strftime('%Y%m%d_%H%M%S', time.localtime())
        filename = vname + ' VS ' + cname + ' run ' + str(run_no) + '.his'
        runs_dir = path

        if not os.path.isdir(runs_dir):
            os.makedirs(runs_dir)

        full_path = runs_dir + '/' + filename
        return open(full_path, "w")

    def update_traces(self, traces):
        """ Loads a list of aircraft traces into the XCombat run format. """

        for timeslice in zip(*traces):
            for aircraft in timeslice:
                t, x, y, z, psi, theta, phi, v, weight, fuel = aircraft
                ac = AircraftState()
                ac.update_state(t, x, y, z, psi, theta, phi, v, weight, fuel)
                self.timeslices.append(ac)

    def update_history(self, state_histories):
        """ Converts the list of fighter state histories into the xcombat format. """

        for timeslice in zip(*state_histories):
            for fighter in timeslice:
                ac = AircraftState()
                ac.ac_ident = fighter.id
                ac.side = fighter.side
                ac.actype = fighter.actype
                ac.timestep = int(10 * (fighter.timestep + 0.1))
                ac.x = utils.metres_to_feet(fighter.x)
                ac.y = utils.metres_to_feet(fighter.y)
                ac.z = utils.metres_to_feet(-fighter.z)
                ac.psi = int(10 * fighter.psi)
                ac.theta = int(10 * fighter.theta)
                ac.phi = int(10 * fighter.phi)
                ac.mach = int(1000 * utils.mps_to_mach(fighter.v))
                ac.eta = int(100 * fighter.gload)

                    # Radar Parameters
                ac.beam_azimuth = 0 #int(100 * fighter.psi)
                ac.beam_elevation = 0 #-int(100 * fighter.theta)
                ac.horizontal_scan = 100 * int(fighter.sensor_state.fov / 2.0)
                ac.vertical_scan = 100 * int(fighter.sensor_state.fov / 2.0)
                ac.radar_range = int(utils.metres_to_feet(fighter.sensor_state.max_range))
                ac.inst_beam_azimuth = 0
                ac.inst_beam_elevation = 0
                #ac.beam_height = 100 * int(fighter.sensor_state.fov / 2.0)
                #ac.beam_width = 100 * int(fighter.sensor_state.fov / 2.0)
                ac.beam_height = 100
                ac.beam_width = 100

                    # Check to see if I have a track. 
                    # If I do, point to it.
                n_tracks = len(fighter.sensor_state.tracks.keys())
                if n_tracks > 0:
                    t = fighter.sensor_state.tracks.values()[0]
                    psi = t.track_psi
                    theta = t.track_theta
                    ac.inst_beam_azimuth = -int(100.0 * psi)
                    ac.inst_beam_elevation = -int(100.0 * (90.0 - theta))
                    ac.radar_range = utils.metres_to_feet(t.track_range)
                
                    # Set the comque
                comque = "00000000000"
                if fighter.tracked == True:
                    comque = "00000001000"
                ac.comque = comque

                self.timeslices.append(ac)

    def generate_run_history(self):
        """ Generates a history file for xcombat visualisation. """
        self.file.write(self.version)
        self.file.write(self.comment)
        self.file.write(self.generated)
        self.file.write(self.model_line)
        self.file.write(self.ac_side_str)
        self.file.write(self.n_waypoints)

        for t in self.timeslices:
            ac_tuple = (t.timestep, t.mfly, t.deadflag, t.ac_ident, t.side, \
                       t.x, t.y, t.z, t.psi, t.theta, t.phi, t.alpha, \
                       t.mach, t.throt, t.eta, t.actype, t.n_flares, \
                       t.beam_elevation, t.beam_azimuth, \
                       t.horizontal_scan, t.vertical_scan, t.radar_range, \
                       t.inst_beam_azimuth, t.inst_beam_elevation, \
                       t.beam_height, t.beam_width, \
                       t.clutter_patch_1_x, t.clutter_patch_1_y, \
                       t.clutter_patch_2_x, t.clutter_patch_2_y, \
                       t.clutter_area_1, t.clutter_area_2, \
                       t.clutter_lobe_1, t.clutter_lobe_2, t.clutter_patch_prf, \
                       t.comque)

            ac_str = ('%4d %4d %4d %4d %4d %6d %6d %6d '
                      '%4d %4d %4d %4d %4d %4d %4d %4d '
                      '%4d %4ld %4ld %4ld %4ld %4ld %4ld %4ld %4ld '
                      '%4ld %4d %4d %4d %4d %4d %4d %4d %4d %4d %12s\n')
            ac_line = ac_str % ac_tuple
            self.file.write(ac_line)
