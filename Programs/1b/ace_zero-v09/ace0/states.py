""" This module contains classes representing the state of an object in the
simulation. These states contain information describing the object and may be
passed to agents to enable decision making. """

__author__ = 'lrbenke, mikepsn'

class SensorTrack(object):
    """ Data generated by the sensor model for each entity it is tracking. """
    def __init__(self):
        self.callsign = ''
        self.id = None
        self.side = None
        self.x = 0.0
        self.y = 0.0
        self.z = 0.0
        self.v = 0.0
        self.track_range = 0.0
        self.track_theta = 0.0
        self.track_psi = 0.0
        self.start_time = 0.0
        self.current_time = 0.0
        self.total_time = 0.0

class SensorState(object):
    
    def __init__(self):
        self.name = ""
        self.max_range = 10000.0
        self.fov = 60.0
        self.tracks = {}


class FighterState(object):
    def __init__(self, x, y, z,
                 vx, vy, vz,
                 ax, ay, az,
                 z_c, psi, psi_c,
                 theta, theta_c,
                 phi, phi_c, v,
                 v_c, gload):
        self.timestep = 0.0
        self.callsign = "callsign"  # aircraft's unique callsign
        self.id = 0             # unique aircraft id (starting at 0)
        self.side = 1           # side aircraft belongs to (either 1 or 2)
        self.actype = 0         # aircraft type
        self.x = x              # x position or lat
        self.y = y              # y position or lon
        self.z = z              # z position or altitude
        self.vx = vx            # velocity on x
        self.vy = vy            # velocity on y
        self.vz = vz            # velocity on z
        self.ax = ax            # acceleration on x
        self.ay = ay            # acceleration on y
        self.az = az            # acceleration on z
        self.z_c = z_c          # desired altitude
        self.psi = psi          # heading
        self.psi_c = psi_c      # desired heading
        self.theta = theta      # pitch angle
        self.theta_c = theta_c  # desired pitch angle
        self.phi = phi          # roll angle
        self.phi_c = phi_c      # desired roll angle
        self.v = v              # velocity
        self.v_c = v_c          # desired velocity
        self.gload = gload      # gload factor
        self.sensor_state = None
        self.tracked = False

    @property
    def heading(self):
        return self.psi

    @property
    def desired_heading(self):
        return self.psi_c

    @property
    def pitch(self):
        return self.theta

    @property
    def desired_pitch(self):
        return self.theta_c

    @property
    def desired_v(self):
        return self.v_c

    @property
    def roll(self):
        return self.phi

    @property
    def desired_roll(self):
        return self.phi_c

    @property
    def gload_factor(self) :
        return self.gload

    def pos_2d(self):
        """ Returns an (x,y) tuple representing the aircraft position. """
        return self.x, self.y

    def pos_3d(self):
        """ Returns an (x,y,z) tuple representing the aircraft position. """
        return self.x, self.y, self.z

    def vel_3d(self):
        """ Returns an (x,y,z) tuple representing the aircraft velocity. """
        return self.vx, self.vy, self.vz

    def acc_3d(self):
        """ Returns an (x,y,z) tuple representing the aircraft acceleration. """
        return self.ax, self.ay, self.az

    def tactical_3d(self):
        """ Returns an (x,y,z) tuple representing the aircraft position. """
        return self.x, self.y, self.z, self.vx, self.vy, self.vz, self.ax, self.ay, self.az, self.psi, self.theta, self.phi, self.v

    def rotations(self):
        return self.psi, self.theta, self.phi

    def __str__(self) :
        tokens = []
        tokens += [ 'x({})={}'.format(self.callsign,self.x)]
        tokens += [ 'y({})={}'.format(self.callsign,self.y)]
        tokens += [ 'z({})={}'.format(self.callsign,self.z)]
        tokens += ['vx({})={}'.format(self.callsign, self.vx)]
        tokens += ['vy({})={}'.format(self.callsign, self.vy)]
        tokens += ['vz({})={}'.format(self.callsign, self.vz)]
        tokens += ['ax({})={}'.format(self.callsign, self.ax)]
        tokens += ['ay({})={}'.format(self.callsign, self.ay)]
        tokens += ['az({})={}'.format(self.callsign, self.az)]
        # tokens += [ 'z_c({})={}'.format(self.callsign,self.z_c)]
        # tokens += [ 'phi({})={}'.format(self.callsign,self.phi)]
        # tokens += [ 'phi_c({})={}'.format(self.callsign,self.phi_c)]
        # tokens += [ 'psi({})={}'.format(self.callsign,self.psi)]
        # tokens += [ 'psi_c({})={}'.format(self.callsign,self.psi_c)]
        # tokens += [ 'theta({})={}'.format(self.callsign,self.theta)]
        # tokens += [ 'theta_c({})={}'.format(self.callsign,self.theta_c)]
        # tokens += [ 'v({})={}'.format(self.callsign,self.v)]
        # tokens += [ 'v_c({})={}'.format(self.callsign,self.v_c)]
        # tokens += [ 'gload({})={}'.format(self.callsign,self.gload)]
        return ', '.join(tokens)
